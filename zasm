#!/usr/bin/java --source 11
//   zen-x assembler

import java.nio.charset.*;
import java.nio.file.*;
import java.util.*;

public class zasm {
  private static ArrayList<Statement> stmts = new ArrayList<>();

  public static void main(String[] args) throws Throwable {
    String srcPathStr = args.length == 0 ? "rom.zasm" : args[0];
    Path srcPath = Paths.get(srcPathStr);
    if (!Files.exists(srcPath)) {
      System.out.println("source file '" + srcPath + "' not found");
      return;
    }
    System.out.println("compiling: " + srcPath);
    String srcIn = Files.readString(srcPath);
    Tokenizer tz = new Tokenizer(srcIn);
    StringBuilder srcOut = new StringBuilder();
    while (true) {
      Token zn = tz.nextToken();
      if (zn.id().endsWith(":")) {
        stmts.add(new Label(zn, tz));
        continue;
      }
      if (zn.isId("#")) {
        stmts.add(new Comment(zn, tz));
        continue;
      }
      Token id = null;
      if (zn.isId("ifz") || zn.isId("ifn") || zn.isId("ifp")) {
        id = tz.nextToken();
        if (id.isEmpty()) throw new Exception(id.sourcePos() + ": unexpected end of file");
      }
      if (zn.isEmpty()) {
        stmts.add(new Eof(zn));
        break;
      }
      if (id == null) {
        id = zn;
        zn = null;
      }
      if (id.isId("ldi")) {
        stmts.add(new OpLdi(zn, id, tz));
      } else if (id.isId("st")) {
        stmts.add(new OpSt(zn, id, tz));
      } else if (id.isId("ld")) {
        stmts.add(new OpLd(zn, id, tz));
      } else if (id.isId("addi")) {
        stmts.add(new OpAddi(zn, id, tz));
      } else if (id.isId("add")) {
        stmts.add(new OpAdd(zn, id, tz));
      } else if (id.isId("sub")) {
        stmts.add(new OpSub(zn, id, tz));
      } else if (id.isId("or")) {
        stmts.add(new OpOr(zn, id, tz));
      } else if (id.isId("xor")) {
        stmts.add(new OpXor(zn, id, tz));
      } else if (id.isId("and")) {
        stmts.add(new OpAnd(zn, id, tz));
      } else if (id.isId("not")) {
        stmts.add(new OpNot(zn, id, tz));
      } else if (id.isId("cp")) {
        stmts.add(new OpCp(zn, id, tz));
      } else if (id.isId("shf")) {
        stmts.add(new OpShf(zn, id, tz));
      } else if (id.isId("jmp")) {
        stmts.add(new OpJmp(zn, id, tz));
      } else if (id.isId("call")) {
        stmts.add(new OpCall(zn, id, tz));
      } else if (id.isId("wl")) {
        stmts.add(new OpWl(zn, id, tz));
      } else if (id.isId("wh")) {
        stmts.add(new OpWh(zn, id, tz));
      } else if (id.isId("rl")) {
        stmts.add(new OpRl(zn, id, tz));
      } else if (id.isId("rh")) {
        stmts.add(new OpRh(zn, id, tz));
      } else {
        short data = Statement.parseImm16(id);
        stmts.add(new OpData(id));
      }
    }

    Toc toc = new Toc();
    // ? messy handling of comments that are on the same line as the statement
    // example:
    //  cp r1 r1  # comment statement is after the statement that needs compile
    int i = 0;
    final int n = stmts.size();
    while (true) {
      if (i==n) break;
      Statement st = stmts.get(i);
      String src = st.toSource();
      toc.addComment(src);
      srcOut.append(src);
      i++;
      if (i==n) break;
      Statement cmnt = stmts.get(i);
      if (cmnt instanceof Comment) {
        String s = cmnt.toSource();
        toc.addComment(s);
        srcOut.append(s);
        i++;
      }
      st.compile(toc);
    }
    toc.link();

    String src = srcOut.toString();
    if (!src.toString().equals(srcIn)) {
      Path fileDiff = Paths.get("diff");
      Files.write(fileDiff, src.getBytes(StandardCharsets.UTF_8));
      System.out.println("!!! source and parsed source differ. See file 'diff'");
    }
    // String compiled = toc.toHexString();
    String compiled = toc.toAnnotatedHexString();

    String compiledPathStr = srcPathStr.substring(0, srcPathStr.lastIndexOf('.')) + ".hex";
    Files.write(Paths.get(compiledPathStr), compiled.getBytes(StandardCharsets.UTF_8));
    System.out.println("    wrote: " + compiledPathStr);
  }
}

class Toc {
  public enum LinkType {
    CALL,
    JMP,
    LDI
  }

  private ArrayList<Short> instrs = new ArrayList<>();
  private ArrayList<Statement> stmts = new ArrayList<>();
  private ArrayList<ArrayList<String>> comments = new ArrayList<>();
  private ArrayList<Link> links = new ArrayList<>();
  private HashMap<String, Label> labels = new HashMap<>();
  private int pc;

  private static class Link {
    int pc;
    String to;
    LinkType type;
    Token tk;

    public Link(int pc, String to, LinkType type, Token tk) {
      this.pc = pc;
      this.to = to;
      this.type = type;
      this.tk = tk;
    }
  }

  private static class Label {
    int pc;
    String name;
    boolean isFunc;

    public Label(int pc, String name, boolean isFunc) {
      this.pc = pc;
      this.name = name;
      this.isFunc = isFunc;
    }
  }

  private void ensureCommentsArraySize() {
    final int n = comments.size();
    final int m = pc + 1;
    for (int i = n; i < m; i++) {
      comments.add(null);
    }
  }

  private List<String> commentsListForCurrentPc() {
    ensureCommentsArraySize();
    ArrayList<String> ls = comments.get(pc);
    if (ls == null) {
      ls = new ArrayList<>();
      comments.set(pc, ls);
    }
    return ls;
  }

  public void addComment(String txt) {
    commentsListForCurrentPc().add(txt);
  }

  public void write(Statement stmt, short instr) {
    stmts.add(stmt);
    instrs.add(Short.valueOf(instr));
    pc++;
  }

  public void write(Statement stmt, short instr, LinkType linkType, String label, Token tk) {
    links.add(new Link(pc, label, linkType, tk));
    write(stmt, instr);
  }

  public void addLabel(String name, boolean isFunc) {
    if (isFunc) { // align at 16 bytes
      if ((pc & 0xf) != 0) {
        pc = (pc & 0xfff0) + 0x10;
      }
    }
    labels.put(name, new Label(pc, name, isFunc));
  }

  public void link() throws Throwable {
    for (Link lnk : links) {
      Label lbl = labels.get(lnk.to);
      if (lbl == null) {
        throw new Exception(lnk.tk.sourcePos() + ": label '" + lnk.to + "' not declared");
      }
      short instr = instrs.get(lnk.pc);
      switch (lnk.type) {
        case CALL:
          assert ((lbl.pc & 0xf) == 0);
          instr |= lbl.pc;
          break;

        case JMP:
          int dpc = lbl.pc - lnk.pc;
          if (dpc > 2047 || dpc < -2048) {
            throw new Exception(
                lnk.tk.sourcePos()
                    + ": jmp to '"
                    + lbl.name
                    + "' out-of-range (offset: "
                    + dpc
                    + ")");
          }
          instr |= (dpc & 0xfff) << 4;
          break;

        case LDI:
          instr = (short) lbl.pc;
          break;

        default:
          assert (false);
      }
      instrs.set(lnk.pc, instr);
    }
  }

  public String toHexString() {
    StringBuilder sb = new StringBuilder();
    int j = 0;
    int k = 0;
    final int n = instrs.size();
    for (int i = 0; i < n; i++) {
      short instr = instrs.get(i);
      sb.append(String.format("%04X", instr)).append(' ');
      j++;
      if (j > 3) {
        sb.append('\n');
        j = 0;
        k++;
        if (k > 3) {
          sb.append('\n');
          k = 0;
        }
      }
    }
    sb.append('\n');
    return sb.toString();
  }

  public String toAnnotatedHexString() {
    StringBuilder sb = new StringBuilder();
    int j = 0;
    int k = 0;
    final int n = instrs.size();
    // ? messy handling of comments
    ensureCommentsArraySize();
    for (int i = 0; i < n; i++) {
      ArrayList<String> cmnts = comments.get(i);
      if (cmnts != null) {
        boolean lastCommentHadNewline = true;
        for (String s : cmnts) {
          if (lastCommentHadNewline) {
            sb.append("// ");
          }
          String s1 = s.replaceAll("\n", "\n// ");
          if (s.endsWith("\n")) {
            s1 = s1.substring(0, s1.length() - 3);
            lastCommentHadNewline = true;
          } else {
            lastCommentHadNewline = false;
          }
          sb.append(s1);
        }
        if (!lastCommentHadNewline) {
          sb.append('\n');
        }
      }
      short instr = instrs.get(i);
      sb.append(String.format("%04X", instr)).append(" // ");
      Statement stmt = stmts.get(i);
      if (stmt != null) {
        sb.append("[").append(i).append("] ").append(stmt.sourcePos()).append('\n');
      }
    }
    sb.append("\n\n// padding: " + (0x10000 - n) + " words\n");
    for (int i = n; i < 0x10000; i++) {
      sb.append("0 ");
    }
    sb.append('\n');
    return sb.toString();
  }
}

class OpData extends Statement {

  public OpData(Token data) {
    super(null, data);
  }

  public void compile(Toc toc) throws Throwable {
    toc.write(this, parseImm16(token()));
  }
}

class OpRl extends Statement {
  private Token regb;

  public OpRl(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short b = registerAddressFromToken(regb);
    instr |= 3 << 4;
    instr |= 6 << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpRh extends Statement {
  private Token regb;

  public OpRh(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short b = registerAddressFromToken(regb);
    instr |= 3 << 4;
    instr |= 0xe << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpWh extends Statement {
  private Token regb;

  public OpWh(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short b = registerAddressFromToken(regb);
    instr |= 3 << 4;
    instr |= 0xa << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpWl extends Statement {
  private Token regb;

  public OpWl(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short b = registerAddressFromToken(regb);
    instr |= 3 << 4;
    instr |= 2 << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + regb.toSource() + toSourceRet();
  }
}

class Eof extends Statement {
  private Token tk;

  public Eof(Token tk) {
    super(null, tk);
  }
}

class Label extends Statement {
  private Token func;

  public Label(Token nm, Tokenizer tz) {
    super(null, nm);
    Token tp = tz.nextToken();
    if (tp.isId("func")) {
      func = tp;
    } else {
      tz.pushBackToken(tp);
    }
  }

  private Token nm;

  public void compile(Toc toc) throws Throwable {
    final String id = id();
    toc.addLabel(id.substring(0, id.length() - 1), func != null);
  }

  public String toSource() {
    return super.toSource() + (func != null ? func.toSource() : "");
  }
}

class Comment extends Statement {
  private Token tk;
  private String txt;

  public Comment(Token tk, Tokenizer tz) {
    super(null, tk);
    txt = tz.readComment();
  }

  public String toSource() {
    return super.toSource() + txt;
  }
}

class OpCall extends Statement {
  private Token lbl;

  public OpCall(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    lbl = tz.nextToken();
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    instr |= 0x8;
    toc.write(this, instr, Toc.LinkType.CALL, lbl.id(), lbl);
  }

  public String toSource() {
    return super.toSource() + lbl.toSource();
  }
}

class OpJmp extends Statement {
  private Token lbl;

  public OpJmp(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    lbl = tz.nextToken();
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    instr |= 0xc;
    toc.write(this, instr, Toc.LinkType.JMP, lbl.id(), lbl);
  }

  public String toSource() {
    return super.toSource() + lbl.toSource();
  }
}

class OpShf extends Statement {
  private Token imm4;
  private Token regb;

  public OpShf(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    imm4 = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = parseSignedPosIncImm4(imm4);
    short b = registerAddressFromToken(regb);
    if (a > 8 || a < -8) {
      throw new Exception(
          imm4.sourcePos()
              + ": immediate 4 bit value '"
              + a
              + "' is not within -8 to 8 excluding 0 range.");
    }
    instr |= 0xe << 4;
    if (a >= 0) {
      a--;
    }
    short imm4 = (short) (a >= 0 ? a : (((a & 0x07) - 8) & 0xf));
    instr |= imm4 << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + imm4.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpCp extends Statement {
  private Token rega;
  private Token regb;

  public OpCp(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    rega = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = registerAddressFromToken(rega);
    short b = registerAddressFromToken(regb);
    instr |= 0xc << 4;
    instr |= a << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + rega.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpNot extends Statement {
  private Token rega;
  private Token regb;

  public OpNot(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    rega = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = registerAddressFromToken(rega);
    short b = registerAddressFromToken(regb);
    instr |= 0xa << 4;
    instr |= a << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + rega.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpAnd extends Statement {
  private Token rega;
  private Token regb;

  public OpAnd(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    rega = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = registerAddressFromToken(rega);
    short b = registerAddressFromToken(regb);
    instr |= 8 << 4;
    instr |= a << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + rega.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpXor extends Statement {
  private Token rega;
  private Token regb;

  public OpXor(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    rega = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = registerAddressFromToken(rega);
    short b = registerAddressFromToken(regb);
    instr |= 6 << 4;
    instr |= a << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + rega.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpOr extends Statement {
  private Token rega;
  private Token regb;

  public OpOr(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    rega = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = registerAddressFromToken(rega);
    short b = registerAddressFromToken(regb);
    instr |= 4 << 4;
    instr |= a << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + rega.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpSub extends Statement {
  private Token rega;
  private Token regb;

  public OpSub(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    rega = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = registerAddressFromToken(rega);
    short b = registerAddressFromToken(regb);
    instr |= 2 << 4;
    instr |= a << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + rega.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpAdd extends Statement {
  private Token rega;
  private Token regb;

  public OpAdd(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    rega = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = registerAddressFromToken(rega);
    short b = registerAddressFromToken(regb);
    instr |= a << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }

  public String toSource() {
    return super.toSource() + rega.toSource() + regb.toSource() + toSourceRet();
  }
}

class OpAddi extends Statement {
  private Token imm4;
  private Token regb;

  public OpAddi(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    imm4 = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public String toSource() {
    return super.toSource() + imm4.toSource() + regb.toSource() + toSourceRet();
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = parseSignedPosIncImm4(imm4);
    short b = registerAddressFromToken(regb);
    if (a > 8 || a < -8) {
      throw new Exception(
          imm4.sourcePos()
              + ": immediate 4 bit value '"
              + a
              + "' may be -8 through 8 excluding 0.");
    }
    instr |= 1 << 4;
    if (a >= 0) {
      a--;
    }
    short imm4 = (short) (a >= 0 ? a : (((a & 0x07) - 8) & 0xf));
    instr |= imm4 << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }
}

class OpLd extends Statement {
  private Token rega;
  private Token regb;

  public OpLd(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    rega = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public String toSource() {
    return super.toSource() + rega.toSource() + regb.toSource() + toSourceRet();
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = registerAddressFromToken(rega);
    short b = registerAddressFromToken(regb);
    instr |= 5 << 4;
    instr |= a << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }
}

class OpSt extends Statement {
  private Token rega;
  private Token regb;

  public OpSt(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    rega = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public String toSource() {
    return super.toSource() + rega.toSource() + regb.toSource() + toSourceRet();
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short a = registerAddressFromToken(rega);
    short b = registerAddressFromToken(regb);
    instr |= 7 << 4;
    instr |= a << 8;
    instr |= b << 12;
    toc.write(this, instr);
  }
}

class OpLdi extends Statement {
  private Token regb;
  private Token imm16;

  public OpLdi(Token zn, Token tk, Tokenizer tz) {
    super(zn, tk);
    imm16 = tz.nextToken();
    regb = tz.nextToken();
    readOptionalRet(tz);
  }

  public String toSource() {
    return super.toSource() + imm16.toSource() + regb.toSource() + toSourceRet();
  }

  public void compile(Toc toc) throws Throwable {
    short instr = getZnr();
    short reg = registerAddressFromToken(regb);
    instr |= 3 << 4;
    instr |= reg << 12;
    toc.write(this, instr);
    try {
      short addr = Statement.parseImm16(imm16);
      toc.write(this, addr);
    } catch (Throwable t) {
      toc.write(this, (short) 0, Toc.LinkType.LDI, imm16.id(), imm16);
    }
  }
}

class Statement {
  private Token tk;
  private Token zn;
  private Token ret;

  public Statement(Token zn, Token tk) {
    this.zn = zn;
    this.tk = tk;
  }

  void readOptionalRet(Tokenizer tz) {
    Token tk = tz.nextToken();
    if (tk.isId("ret")) {
      ret = tk;
    } else {
      tz.pushBackToken(tk);
    }
  }

  public String toSource() {
    return (zn == null ? "" : zn.toSource()) + tk.toSource();
  }

  public String toSourceRet() {
    if (ret == null) return "";
    return ret.toSource();
  }

  public short getZnr() {
    short r = (short) (ret == null ? 0 : 4);
    if (zn != null) {
      if (zn.isId("ifz")) {
        return (short) (1 | r);
      }
      if (zn.isId("ifn")) {
        return (short) (2 | r);
      }
      if (zn.isId("ifp")) {
        return (short) (0 | r);
      }
    }
    return (short) (3 | r);
  }

  public void compile(Toc toc) throws Throwable {}

  public String id() {
    return tk.id();
  }

  public Token token() {
    return tk;
  }

  public String sourcePos() {
    return zn == null ? tk.sourcePos() : zn.sourcePos();
  }

  public static short registerAddressFromToken(Token addr) throws Throwable {
    short a = Short.parseShort(addr.id().substring(1));
    if (a < 0 || a > 15) {
      throw new Exception(
          addr.sourcePos()
              + ": unknown register '"
              + addr.id()
              + "'. valid registers 'r0' through 'r15'");
    }
    return a;
  }

  public static short parseImm16(Token tk) throws Throwable {
    try {
      int i;
      if (tk.id().startsWith("0b")) {
        i = Integer.parseInt(tk.id().substring(2), 2);
      } else {
        i = Integer.decode(tk.id()).intValue();
      }
      if (i < 0 && i < Short.MIN_VALUE)
        throw new Exception(
            tk.sourcePos()
                + ": negative value '"
                + tk.id()
                + "' ("
                + i
                + ") does not fit in 16 bits. min value is "
                + Short.MIN_VALUE);
      if (i > 0 && i > (1 << 16) - 1)
        throw new Exception(
            tk.sourcePos()
                + ": positive value '"
                + tk.id()
                + "' ("
                + i
                + ") does not fit in 16 bits. max value is "
                + ((1 << 16) - 1));
      return (short) i;
    } catch (NumberFormatException e) {
      throw new Exception(tk.sourcePos() + ": cannot parse '" + tk.id() + "' to a number");
    }
  }

  public static short parseSignedPosIncImm4(Token tk) throws Throwable {
    int a = Integer.decode(tk.id()).shortValue();
    if (a == 0)
      throw new Exception(
          tk.sourcePos() + ": signed immediate 4 bit value in this context is not allowed to be 0");

    if (a > 8 || a < -8) {
      throw new Exception(
          tk.sourcePos()
              + ": signed immediate 4 bit value '"
              + a
              + "' is not within -8 to 8 (with 0 being invalid).");
    }
    return (short) a;
  }
}

class Token {
  private String ws_lft;
  private String id;
  private String ws_rht;
  private int pos_ws_lft;
  private int pos_strt;
  private int pos_end;
  private int pos_ws_rht;
  private int linenm;
  private int charnm;

  public Token(
      String id,
      String ws_lft,
      String ws_rht,
      int pos_ws_lft,
      int pos_strt,
      int pos_end,
      int pos_ws_rht,
      int linenm,
      int charnm) {
    this.id = id;
    this.ws_lft = ws_lft;
    this.ws_rht = ws_rht;
    this.pos_ws_lft = pos_ws_lft;
    this.pos_strt = pos_strt;
    this.pos_end = pos_end;
    this.pos_ws_rht = pos_ws_rht;
    this.linenm = linenm;
    this.charnm = charnm;
  }

  public String toSource() {
    return ws_lft.toString() + id.toString() + ws_rht.toString();
  }

  public String toDebug() {
    return linenm + ":" + charnm + ": " + id;
  }

  public boolean isEmpty() {
    return id.length() == 0;
  }

  public boolean isId(String s) {
    return id.equals(s);
  }

  public String id() {
    return id;
  }

  public String sourcePos() {
    return linenm + ":" + charnm;
  }

  public int totalNChars() {
    return pos_ws_rht - pos_ws_lft;
  }
}

class Tokenizer {
  private String src;
  private int pos;
  private int linenm = 1; // current line number
  private int charnm = 1; // character number on current line

  public Tokenizer(String src) {
    this.src = src;
  }

  public Token nextToken() {
    int pos_ws_lft;
    int pos_strt;
    int pos_end;
    int pos_ws_rht;
    StringBuilder sb_ws_lft = new StringBuilder();
    StringBuilder sb_id = new StringBuilder();
    StringBuilder sb_ws_rht = new StringBuilder();

    int p = pos;
    pos_ws_lft = p;
    while (true) {
      if (p == src.length()) break;
      char ch = src.charAt(p);
      if (Character.isWhitespace(ch)) {
        sb_ws_lft.append(ch);
        p++;
        if (ch == '\n') {
          linenm++;
          charnm = 1;
        } else {
          charnm++;
        }
        continue;
      }
      break;
    }
    pos_strt = p;
    int token_linenm = linenm;
    int token_charnm = charnm;
    while (true) {
      if (p == src.length()) break;
      char ch = src.charAt(p);
      if (Character.isWhitespace(ch)) break;
      sb_id.append(ch);
      p++;
      charnm++;
      continue;
    }
    pos_end = p;
    while (true) {
      if (p == src.length()) break;
      char ch = src.charAt(p);
      if (Character.isWhitespace(ch)) {
        sb_ws_rht.append(ch);
        p++;
        if (ch == '\n') {
          linenm++;
          charnm = 1;
          break;
        } else {
          charnm++;
        }
        continue;
      }
      break;
    }
    pos_ws_rht = p;
    pos = p;
    Token tk =
        new Token(
            sb_id.toString(),
            sb_ws_lft.toString(),
            sb_ws_rht.toString(),
            pos_ws_lft,
            pos_strt,
            pos_end,
            pos_ws_rht,
            token_linenm,
            token_charnm);
    return tk;
  }

  void pushBackToken(Token tk) {
    int nchars = tk.totalNChars();
    while (nchars-- != 0) {
      pos--;
      if (src.charAt(pos) == '\n') {
        linenm--;
        charnm = findCharNmInCurrentLine();
      } else {
        charnm--;
      }
    }
  }

  private int findCharNmInCurrentLine() {
    // ldi r3 0x0001\nadd_
    int n = 0;
    int p = pos;
    while (true) {
      if (src.charAt(p) == '\n') {
        return pos - p;
      }
      p--;
      if (p == 0) {
        return pos;
      }
    }
  }

  public String readComment() {
    StringBuilder sb = new StringBuilder();
    while (true) {
      if (pos != 0 && src.charAt(pos - 1) == '\n') {
        // check if it is an empty comment. example: "ld 0x1234 r1 #\n"
        // without this check the next line would be read as a comment
        return "";
      }
      char ch = src.charAt(pos);
      sb.append(ch);
      pos++;
      charnm++;
      if (pos == src.length()) {
        return sb.toString();
      }
      if (ch == '\n') {
        linenm++;
        charnm = 1;
        return sb.toString();
      }
    }
  }
}
