[ ] reduce instruction cycles where possible since rom has 1 cycle latency
[ ]   rom data arrives one cycle + ~100ps and a full cycle is wasted because of that
[ ]     => try adding a delay of 1ns in the always block
[ ]       => it overlaps the next cycle by 1ns. how to end the cycle as if there was no delay
[ ]   ldi data can be loaded into register in a single cycle 
[ ] consider making rom 64K and ram 32K to represent a retro computer with 64K program cartidge
[ ] zenx: 1 cycle jmp: always @* if (is_skp) pc = pc + {{(4){imm12[11]}}, imm12};
          doesn't work because 'is_skp' is triggered by previous instruction (ldi data)
          during the ~100ps delay of rom data after "posedge clk"
[ ] zenx: 1 cycle call
[o] uart
[x]   send "hello world" => "HELLO "
[x]   echo
[o] i/o
[o]   step 1: blocking uart
[x]           writes lower 8 bits of r2 to uart
[x]           writes higher 8 bits of r2 to uart
[ ]           reads 8 bits from uart into lower r2
[ ]           reads 8 bits from uart into higher r2
[ ]    step 2: non-blocking uart
[x] uart to operate on negedge to save a cycle
[x] uart simulation operate with baud rate same as clock frequency
[ ] uart: review somewhat messy uart_tx
[ ]
[ ] interrupts
[ ] consider having more cores sharing the same rom and ram
[ ]   'await' instruction that waits for interrupt then continues 
[ ] assembler webapp
[ ] emulator webapp
------------------------------------------------------------------------------
[-] Calls: consolidate push, pop, en to en, sel
      => it gets messy because many combos use push or pop flag
[x] parameterize
[x] check if racing between
[x]   Calls vs Zn
[x]   Calls vs zenx
[x]   zenx vs Zn
[x]   zenx: nededge clk uses comb.condition that is modified during the same time
       => does that during the second cycle while the combo is done during first
[x] call
[x] ret
[x] jmp
[x] zn
[x] is_do_op
[x] st
[x] ld
[x] alu
[x] ldi