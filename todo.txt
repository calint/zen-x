[ ] zenx: consolidate multiple steps and compare resources used on the board
[ ] implement 'ret' on 'ldi' and 'io*'
[ ] built-in 4 leds set by 'led' and 'ledi' instructions
[ ] reduce instruction cycles where possible since rom has 1 cycle latency
[ ]   rom data arrives one cycle + ~100ps and a full cycle is wasted because of that
[ ]     => try adding a delay of 1ns in the always block
[ ]       => it overlaps the next cycle by 1ns. how to end the cycle as if there was no delay
[ ]   ldi data can be loaded into register in a single cycle 
[ ] consider making rom 64K and ram 32K to represent a retro computer with 64K program cartidge
[ ] zenx: 1 cycle jmp: always @* if (is_jmp) pc = pc + {{(4){imm12[11]}}, imm12};
          doesn't work because 'is_jmp' is triggered by previous instruction (ldi data)
          during the ~100ps delay of rom data after "posedge clk"
[ ] zenx: 1 cycle call
[ ] consider having more cores sharing the same rom and ram
[ ] assembler webapp
[ ] emulator webapp
------------------------------------------------------------------------------
[x] set baud rate to something low in the spirit of retro computers
      => 9600
[x] review uart_tx => can operate at BAUD == CLOCK_FREQ
[x] review uart_rx => can operate at BAUD == CLOCK_FREQ / 2
[x] racing: at call Zn and Calls are racing for the zn-flags
      => Calls copies flags at posedge then Zn clears flags at negedge
      at return: Zn copies flags to 'next state' from Calls, Calls copies 'next state' from stack
        at negedge both update state from 'next state'. no racing se "Screenshot from 2023-05-15 10-03-26"
[-]   'await' instruction that waits for interrupt then continues 
        => out of scope of this project
[-] interrupts => out of scope for this experiment
[x] uart
[x]   send "hello world" => "HELLO "
[x]   echo
[x] i/o
[x]   step 1: blocking uart
[x]           writes lower 8 bits of r2 to uart
[x]           writes higher 8 bits of r2 to uart
[x]           reads 8 bits from uart into lower r2
[x]           reads 8 bits from uart into higher r2
[-]    step 2: non-blocking uart
[x] uart to operate on negedge to save a cycle
[x] uart simulation operate with baud rate same as clock frequency
[x] uart 'cat todo.txt > /dev/ttyUSB1' hangs at same location in the file
    => while data is being sent new data received is skipped
[-] Calls: consolidate push, pop, en to en, sel
      => it gets messy because many combos use push or pop flag
[x] parameterize
[x] check if racing between
[x]   Calls vs Zn
[x]   Calls vs zenx
[x]   zenx vs Zn
[x]   zenx: nededge clk uses comb.condition that is modified during the same time
       => does that during the second cycle while the combo is done during first
[x] call
[x] ret
[x] jmp
[x] zn
[x] is_do_op
[x] st
[x] ld
[x] alu
[x] ldi
