[ ] reduce instruction cycles where possible since rom has 1 cycle latency
[ ]   rom data arrives one cycle + ~100ps and a full cycle is wasted because of that
[ ]     => try adding a delay of 1ns in the always block
[ ]       => it overlaps the next cycle by 1ns. how to end the cycle as if there was no delay
[ ]   ldi data can be loaded into register in a single cycle 
[ ] consider making rom 64K and ram 32K to represent a retro computer with 64K program cartidge
[ ] zenx: 1 cycle jmp: always @* if (is_skp) pc = pc + {{(4){imm12[11]}}, imm12};
          doesn't work because 'is_skp' is triggered by previous instruction (ldi data)
          during the ~100ps delay of rom data after "posedge clk"
[ ] zenx: 1 cycle call
[o] uart
[ ]   send "hello world"
[x]   echo
[ ] i/o
[ ] interrupts
[ ] consider having more cores sharing the same rom and ram
[ ]   'await' instruction that waits for interrupt then continues 
[ ] assembler webapp
[ ] emulator webapp
------------------------------------------------------------------------------
[-] Calls: consolidate push, pop, en to en, sel
      => it gets messy because many combos use push or pop flag
[x] parameterize
[x] check if racing between
[x]   Calls vs Zn
[x]   Calls vs zenx
[x]   zenx vs Zn
[x]   zenx: nededge clk uses comb.condition that is modified during the same time
       => does that during the second cycle while the combo is done during first
[x] call
[x] ret
[x] jmp
[x] zn
[x] is_do_op
[x] st
[x] ld
[x] alu
[x] ldi