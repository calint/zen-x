-------------------------------------------------------------
TAG=2023-05-02--2 && git tag $TAG && git push origin $TAG
git reset --hard HEAD
git push --force origin HEAD
-------------------------------------------------------------
`default_nettype none
`default_nettype wire
-------------------------------------------------------------
module block_mem_example (
  input wire clk,
  input wire [9:0] addr,
  input wire we,
  input wire [31:0] data_in,
  output wire [31:0] data_out
);

  // Instantiate the block memory
  (* ram_style = "block" *) reg [31:0] mem [0:1023];

  // Read data from memory
  assign data_out = mem[addr];

  // Write data to memory
  always @ (posedge clk) begin
    if (we) begin
      mem[addr] <= data_in;
    end
  end

endmodule
-------------------------------------------------------------
Filename: rams_sp_wf.v
// Single-Port Block RAM Write-First Mode (recommended template)
// File: rams_sp_wf.v
module rams_sp_wf (clk, we, en, addr, di, dout);
  input clk;
  input we;
  input en;
  input [9:0] addr;
  input [15:0] di;
  output [15:0] dout;

reg [15:0] RAM [1023:0];
reg [15:0] dout;

always @(posedge clk) begin
  if (en) begin
    if (we) begin
      RAM[addr] <= di;
      dout <= di;
    end else
      dout <= RAM[addr];
  end
end

endmodule
-------------------------------------------------------------
reg delayed_clk;
always @(posedge clk or negedge clk) begin
  if (clk) begin
    #1;
    delayed_clk <= 1;
  end else begin
    delayed_clk <= 0;
  end
end
-------------------------------------------------------------
write_cfgmem -format mcs -size 4 -interface SPIx4 -loadbit {up 0x00000000 "/home/c/w/zen-x/zen-x.runs/impl_1/Sys.bit" } -file "/home/c/w/zen-x/zen-x.runs/impl_1/zenx"
-------------------------------------------------------------
reg [7:0] data_out;
wire [7:0] data_in;
wire rx_done;
reg rx_bsy_prv;
wire tx_bsy;
reg tx_go;
reg state; // 0: waiting for rx_done, 1: waiting for tx_done

uart_rx #(
    CLK_FREQ,
    BAUD_RATE
) urx (
    .rst(!clk_locked),
    .clk(clk),
    .data(data_in),
    .rx_done(rx_done),
    .rx(uart_rx)
);

uart_tx #(
    CLK_FREQ,
    BAUD_RATE
) utx (
    .rst(!clk_locked),
    .clk(clk),
    .data(data_out),
    .tx_go(tx_go),
    .tx(uart_tx),
    .tx_bsy(tx_bsy)
);

always @(posedge clk) begin
    if (!clk_locked) begin
        tx_go <= 0;
        rx_bsy_prv <= 0;
        data_out <= 0;
        state <= 0;
    end else begin
        case(state)
        0: begin
            if (rx_done_prv != rx_done) begin
                rx_done_prv <= rx_done;
                if (rx_done) begin
                    data_out <= data_in;
                    tx_go <= 1;
                    state <= 1;
                end
            end
        end
        1: begin
            if (tx_done) begin
                tx_go <= 0;
                state <= 0;
            end
        end
        endcase
    end
 end
-------------------------------------------------------------
wire [REGISTERS_WIDTH-1:0] alu_operand_a =
    op == OP_SHF ? {{(REGISTERS_WIDTH-4){rega[3]}},rega} : 
    op == OP_ADDI ? rega[3] ? {{(REGISTERS_WIDTH-4){rega[3]}},rega} : {{(REGISTERS_WIDTH-4){1'b0}},rega} + 1 :
    regs_dat_a; // otherwise regs[a]
-------------------------------------------------------------
